FirstPixelGetter
Input:
	- pixel data
Output:
	- origin pixel, pixel data

SquareGetter
Input:
- origin_pixel, pixel data
Output:
- if square: call to PixelChomper with start pixel, end pixel, pixel data
- if no square: call to HorizontalLineGetter with origin pixel, pixel data
Test cases:
- with single pixel, vertical line and horizontal line
	- should call next handler with origin pixel and pixel data

HorizontalLineGetter
Input:
- origin_pixel, pixel data
Output:
- if h_line: call to PixelChomper with start pixel, end pixel, pixel data
- if no h_line: call to VerticalLineGetter with origin pixel, pixel data
Test cases:
- unhappy:
	- single pixel
	- single pixel with diff color pixel next to it
	- single pixel with gap next to it
	- vertical line
	

VerticalLineGetter
Input:
- origin_pixel, pixel data
Output:
- THIS IS INTERESTING: we can ALWAYS call PixelChomper at this point:
	- if v_line: call to PixelChomper with start pixel, end pixel, pixel data
	- if no v_line: STILL call to PixelChomper with start pixel, end pixel, pixel data:
		- but this time, start pixel and end pixel will BOTH be origin pixel

PixelChomper
Input:
- start pixel, end pixel, pixel data
Output:
- always call to ResultsCompiler with start_pixel, end pixel, AMENDED pixel data

ResultsCompiler
This class is initialized with an empty results hash
Input:
- start_pixel, end pixel, pixel data
Logic:
- adds to results hash
Output:
- if pixel data empty: returns results hash
- if pixel data not empty: calls FirstPixelGetter with pixel data

----
A way to delete (and return) a pixel: pixel_data[0].pop(0)

Example of testing raise:
	with self.assertRaises(PixelNotFound) as context:
	  is_rect(origin_pixel, corner_pixel, pixel_data)

	self.assertTrue('y:0, x:1' in str(context.exception))



TODO:
- MVP 1:
	- input: an array of tuples representing a red square
	- output: a pair of x and y coordinates representing a red rect

End MVP:
- input: png
- output: a string for a p8 function that represents the png as
p8 code using rectfill, line, pset.

Other MVPs:
- black is treated as transparent by p8. But what if it is included in a sprite (as an outline color for example)?

FINDINGS:
- opencv article: https://pyimagesearch.com/2021/01/20/opencv-getting-and-setting-pixels/
- pico8 palette rgb data: https://pico-8.fandom.com/wiki/Palette

Nice-to-haves:
- params for the output function so that user can specify where to draw the sprite
on the screen
- error handling
	- file is not png
	- file is empty
	- colors not in pico8 palette
- flags to give additoinal output like:
	- token count of output
	- colors used
	- dimensions of png

DONE:
- MVP 0:
	- read article
	- what is the most efficinet way to get neighbouring pixels
	- create two PNGs
		- 1 red pixel
		- 1 multicolored square, 2x2
	- what does opencv output for the above?
	- what test framework can you use?
	- create a hash
	- set up a test for 1 == 1